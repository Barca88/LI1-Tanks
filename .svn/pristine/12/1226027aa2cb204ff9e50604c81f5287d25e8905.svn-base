-- | Este módulo define funções comuns da Tarefa 4 do trabalho prático.
module Tarefa4_2018li1g142 where

import LI11819
import Tarefa0_2018li1g142
import Tarefa1_2018li1g142
import Tarefa2_2018li1g142

-- * Testes
-- | Testes unitários da Tarefa 4.
--
-- Cada teste é um 'Estado'.
testesT4 :: [Estado]
testesT4 = [Estado (mapaInicial (6,6)) [Jogador (1,1) C 1 1 1] [DisparoChoque 0 3], -- Testa a decrementação de um choque
            Estado (mapaInicial (6,6)) [Jogador (1,1) C 1 1 1] [DisparoChoque 0 0]] -- Testa o fim de um choque


-- * Funções principais da Tarefa 4.

-- | Avança o 'Estado' do jogo um 'Tick' de tempo.
--
-- __NB:__ Apenas os 'Disparo's afetam o 'Estado' do jogo com o passar do tempo.
--
-- __NB:__ Deve chamar as funções 'tickChoques', 'tickCanhoes' e 'tickLasers' pela ordem definida.
tick :: Estado -- ^ O 'Estado' anterior.
     -> Estado -- ^ O 'Estado' após um 'Tick'.
tick = tickChoques . tickCanhoes . tickLasers

-- | Avança o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos dos tiros de 'Laser' disparados.
tickLasers :: Estado -> Estado
tickLasers (Estado m js ds) = if haLasers ds then undefined else e

-- | Avança o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos das balas de 'Canhao' disparadas.
tickCanhoes :: Estado -> Estado 
tickCanhoes e = addOutros ((exeCanhao (e (listaCanhoes ds))) (listaLasers ds) (listaChoques ds))
              where ds = disparosEstado e

-- | Avança o 'Estado' do jogo um 'Tick' de tempo, considerando apenas os efeitos dos campos de 'Choque' disparados.
tickChoques :: Estado -> Estado
tickChoques (Estado m js ds) = if listaChoques ds /= []
                               then Estado m js (listaLasers ds ++ listaCanhoes ds ++ (exeChoque (listaChoques ds)))
                               else e

-- CHOQUE
-- | Executa os choques.
exeChoque :: [Disparo] -> [Disparo]
exeChoque [] = []
exeChoque (h:t) = if fimChoque h then exeChoque t
                                 else decrementaChoque h : exeChoque t

-- | Testa se um choque vai acabar.
fimChoque :: Disparo -> Bool
fimChoque (DisparoChoque _ t) = t == 0

-- | Decrementa o tempo do choque.
decrementaChoque :: Disparo -> Disparo
decrementaChoque (DisparoChoque _ t) = DisparoChoque _ (t-1)   

-- CANHÃO
-- | Executa os canhões.
exeCanhao :: Estado -> [Disparo] -> Estado -- Caso não dê, é possivel que seja porque tenho de meter uma variavel com o nr de elementos da lista de disparo e decrementa-l ate zero para parar a recursividade :)  #hojeosmeusputosvivembem
exeCanhao e [] = e
exeCanhao e ds@(h:t) = case v of
                        0 -> exeCanhao (Estado m js (incrementaCanhao h):t) t
                        1 -> exeCanhao (Estado (mudaMapa h m) js (remove h ds)) t
                        2 -> exeCanhao (Estado m js (removeBalas h ds)) t
                        3 -> exeCanhao (Estado m (lostVidas js) (remove h ds)) t 
                        where v = porqueExplode e h
                              pos = posicaoDisparo h

-- | Devolve o motivo da explusão.
porqueExplode :: Estado -> Disparo -> Int
porqueExplode e d = | temParede d m  = 1
                    | confrontoBalas d (listaCanhoes ds) = 2
                    | temJogador js d = 3
                    | otherwise = 0
                    where ds = disparosEstado e
                          js = jogadoresEstado e
                          m = mapaEstado e

-- | Adiciona os outros tiros à lista com os canhões efetuados.
addOutros :: Estado -> [Disparos] -> [Disparos] -> Estado
addOutros e dlas dcho = Estado m js (dlas ++ dcan ++ dcho)
                      where m = mapaEstado e
                            js = jogadoresEstado e
                            dcan = disparosEstado e  

-- | Avança com a bala do canhão no caso de ele poder avançar.
incrementaCanhao :: Disparo -> Disparo
incrementaCanhao (DisparoCanhao _ (x,y) dir) = case dir of 
                                             C -> DisparoCanhao _ (x-1,y) dir
                                             D -> DisparoCanhao _ (x,y+1) dir
                                             B -> DisparoCanhao _ (x+1,y) dir
                                             E -> DisparoCanhao _ (x,y-1) dir

-- | Remove as balas que estão na mesma posição do disparo.
removeBalas :: Disparo -> [Disparo] -> [Disparo]
removeBalas _ [] = []
removeBalas d (h:t) = if p1 == p2 then removeBalas t 
                                  else h:removeBalas t 
                    where p1 = posicaoDisparo d 
                          p2 = posicaoDisparo h

-- | Testa se duas balas de canhão estão na mesma posição.
confrontoBalas :: Disparo -> [Disparo] -> Bool
confrontoBalas d [] = False
confrontoBalas d (h:t) = if d1 == d2 then True
                         else confrontoBalas d t 
                     where d1 = posicaoDisparo d
                           d2 = posicaoDisparo h

-- | Testa se tem jogadores a ocupar a posição da frente da bala.
temJogador :: [Jogador] -> Disparo -> Bool
temJogador [] _ = False
temJogador (h:t) (DisparoCanhao _ (x,y) dir) = case dir of
                                             C -> if (elem (x-1,y) (allPosJog h)) then True else temJogador t
                                             D -> if (elem (x,y+1) (allPosJog h)) then True else temJogador t
                                             B -> if (elem (x+1,y) (allPosJog h)) then True else temJogador t
                                             E -> if (elem (x,y-1) (allPosJog h)) then True else temJogador t

-- | Testa se tem parede para onde o disparo segue.
temParede :: Disparo -> Mapa -> Bool
temParede (DisparoCanhao _ (x,y) dir) m = case dir of
                                            C -> iNotVazio (x,y) m || iNotVazio (x,y+1) m
                                            D -> iNotVazio (x,y+1) m || iNotVazio (x+1,y+1) m
                                            B -> iNotVazio (x+1,y) m || iNotVazio (x+1,y+1) m
                                            E -> iNotVazio (x,y) m || iNotVazio (x+1,y) m

-- | Devolve uma lista com todas as PosicaoGrelha que um jogador ocupa.
allPosJog :: Jogador -> [PosicaoGrelha]
allPosJog j = [(x-1,y-1),(x-1,y),(x-1,y+1),
               (x,y-1),(x,y),(x,y+1),
               (x+1,y-1),(x+1,y),(x+1,y+1)]
               where (x,y) = posicaoJogador j

-- | Devolve os jgoadores com as vidas perdidas.
lostVidas :: Disparo -> [Jogador] -> [Jogador]
lostVidas _ [] = []
lostVidas d (h:t) = if pos d == allPosJog h then (perdeVida h):lostVidas t
                    else lostVidas t
                    where pos = posicaoDisparo d

-- | Jogador perde uma vida.
perdeVida :: Jogador -> Jogador
perdeVida (Jogador _ _ v _ _) = Jogador _ _ (v-1) _ _

-- | Efetua mudanças no mapa.
mudaMapa :: Disparo -> Mapa -> Mapa
mudaMapa d m = case dir of
                    C -> if temDestrutivel (x,y) m 
                         then if temDestrutivel (x,y+1) m  
                              then destroiParede (x,y) (destroiParede (x,y+1) m)
                              else destroiParede (x,y) m
                         else if temDestrutivel (x,y+1) m 
                              then destroiParede (x,y+1) m 
                              else m
                    D -> if temDestrutivel (x,y+1) m 
                         then if temDestrutivel (x+1,y+1) m  
                              then destroiParede (x,y+1) (destroiParede (x+1,y+1) m)
                              else destroiParede (x,y+1) m
                         else if temDestrutivel (x+1,y+1) m 
                              then destroiParede (x+1,y+1) m 
                              else m
                    B -> if temDestrutivel (x+1,y) m 
                         then if temDestrutivel (x+1,y+1) m  
                              then destroiParede (x+1,y) (destroiParede (x+1,y+1) m)
                              else destroiParede (x+1,y) m
                         else if temDestrutivel (x+1,y+1) m 
                              then destroiParede (x+1,y+1) m 
                              else m
                    E -> if temDestrutivel (x,y) m 
                         then if temDestrutivel (x+1,y) m  
                              then destroiParede (x,y) (destroiParede (x+1,y) m)
                              else destroiParede (x,y) m
                         else if temDestrutivel (x+1,y) m 
                              then destroiParede (x+1,y) m 
                              else m
                    where dir   = direcaoDisparo d
                          (x,y) = posicaoDisparo d

-- | Testa se tem uma parede destrutivel à frente da bala.
temDestrutivel :: Posicao -> Mapa -> Bool
temDestrutivel p m = encontraPosicaoMatriz p m == Bloco Destrutivel

-- | Destroi uma parede destrutivel com um tiro.
destroiParede :: Posicao -> Mapa -> Mapa
destroiParede p m = atualizaPosicaoMatriz p Vazia m

-- LASER




























-- Listas de disparos separadas
-- | Devolve uma lista apenas com lasers
listaLasers :: [Disparo] -> [Disparo]
listaLasers [] = []
listaLasers (h:t) = case h of
                    DisparoLaser -> h:listaLasers t
                    otherwise -> listaLasers t

-- | Devolve uma lista apenas com choques
listaChoques :: [Disparo] -> [Disparo]
listaChoques [] = []
listaChoques (h:t) = case h of
                    DisparoChoque -> h:listaChoques t
                    otherwise -> listaChoques t

-- | Devolve uma lista apenas com tiros de canhão
listaCanhoes :: [Disparo] -> [Disparo]
listaCanhoes [] = []
listaCanhoes (h:t) = case h of
                    DisparoCanhao -> h:listaCanhoes t
                    otherwise -> listaCanhoes t
































































































{-
-- | Devolve True Se o jogador se mover para um sítio onde se encontra um tiro de canhão
haTiro :: Jogador -> Direcao -> [Disparo] -> Bool
haTiro j dir ds = case dir of 
                        C -> elem (x-2,y-1) (posds ds) || elem (x-2,y) (posds ds) || elem (x-2,y+1) (posds ds)
                        D -> elem (x-1,y+2) (posds ds) || elem (x,y+2) (posds ds) || elem (x+1,y+2) (posds ds)
                        B -> elem (x+2,y-1) (posds ds) || elem (x+2,y) (posds ds) || elem (x+2,y+1) (posds ds)
                        E -> elem (x-1,y-2) (posds ds) || elem (x,y-2) (posds ds) || elem (x+1,y-2) (posds ds)
                    where (x,y) = posicaoJogador j


-- | Devolve a lista de posições de tiros de canhão
posds :: [Disparo] -> [PosicaoGrelha]
posds (h:t) = case h of 
                DisparoCanhao i p d -> p : posds t
                otherwise -> posds t


-- | Devolve a lista de disparos ordenada (1ºLasers -> 2ºCanhoes -> 3ºChoques)
ordenaDisparos :: [Disparo] -> [Disparo]
ordenaDisparos ds = listaLasers ds ++ listaCanhoes ds ++ listaChoques ds


-- | Testa se um bloco é vazio.
isVazio :: Posicao -> Mapa -> Bool
isVazio p m = encontraPosicaoMatriz p m == Vazia

-- | Testa se tem uma parede inestrutivel à frente da bala.
temIndestrutivel :: Posicao -> Mapa -> Bool
temIndestrutivel p m = encontraPosicaoMatriz p m == Bloco Indestrutivel
-}

{-
-- Testes de disparos separados
-- | Verifica se há lasers na lista de disparos
haLasers :: [Disparo] -> Bool
haLasers [] = False
haLasers (h:t) = case h of
                    DisparoLaser -> True
                    otherwise -> haLasers t

-- | Verifica se há choques na lista de disparos
haChoques :: [Disparo] -> Bool
haChoques [] = False
haChoques (h:t) = case h of
                    DisparoChoque -> True
                    otherwise -> haChoques t

-- | Verifica se há tiros de canhão na lista de disparos
haCanhoes :: [Disparo] -> Bool
haCanhoes [] = False
haCanhoes (h:t) = case h of
                    DisparoCanhao -> True
                    otherwise -> haCanhoes t
-}